/**
 * Composite is a component that may contain navigable items represented by
 * CompositeItem. It's inspired by the WAI-ARIA Composite Role and implements
 * all the keyboard navigation mechanisms to ensure that there's only one
 * tab stop for the whole Composite element. This means that it can behave as
 * a roving tabindex or aria-activedescendant container.
 *
 * @see https://ariakit.org/components/composite
 */

/**
 * WordPress dependencies
 */
import {
	forwardRef,
	useId as useGeneratedId,
	useState,
} from '@wordpress/element';
import deprecated from '@wordpress/deprecated';

/**
 * Internal dependencies
 */
import * as Current from '../current';
import { useInstanceId } from '@wordpress/compose';

type Orientation = 'horizontal' | 'vertical';

export interface InitialStateProps {
	baseId?: string;
	unstable_virtual?: boolean;
	rtl?: boolean;
	orientation?: Orientation;
	currentId?: string;
	loop?: boolean | Orientation;
	wrap?: boolean | Orientation;
	shift?: boolean;
}

type Component = {
	( ...any: any ): React.ReactElement | null;
	displayName?: string;
};

type BaseIdState = Required< Pick< InitialStateProps, 'baseId' > >;
type BaseId = BaseIdState[ 'baseId' ];

type CompositeStore = ReturnType< typeof Current.useCompositeStore >;
type CompositeStoreState = { store: CompositeStore };
export type CompositeState = CompositeStoreState & BaseIdState;

// Legacy composite components can either state through a single
// `state` prop, or via individual props, usually through spreading
// the state generated by `useCompositeState` (i.e. `{ ...state }`).
export type CompositeStateProps =
	| { state: CompositeState }
	| ( CompositeState & { state?: never } );
type ComponentProps< C extends Component > = React.ComponentPropsWithRef< C >;
export type CompositeProps< C extends Component > = ComponentProps< C > &
	CompositeStateProps;
type CompositeComponent< C extends Component > = (
	props: CompositeProps< C >
) => React.ReactElement;
type CompositeComponentProps = CompositeState &
	(
		| ComponentProps< typeof Current.CompositeGroup >
		| ComponentProps< typeof Current.CompositeItem >
		| ComponentProps< typeof Current.CompositeRow >
	);

function useBaseId( preferredBaseId?: BaseId ): BaseId {
	const generatedId = useGeneratedId();
	const [ baseId ] = useState( preferredBaseId || generatedId );

	return baseId;
}

function mapLegacyStatePropsToComponentProps(
	legacyProps: CompositeStateProps
): CompositeComponentProps {
	// If a `state` prop is provided, we unpack that; otherwise,
	// the necessary props are provided directly in `legacyProps`.
	if ( legacyProps.state ) {
		const { state, ...rest } = legacyProps;
		const { store, ...props } =
			mapLegacyStatePropsToComponentProps( state );
		return { ...rest, ...props, store };
	}

	return legacyProps;
}

function proxyComposite< C extends Component >(
	ProxiedComponent: C | React.ForwardRefExoticComponent< C >,
	propMap: Record< string, string > = {}
): CompositeComponent< C > {
	return ( legacyProps: CompositeStateProps ) => {
		const componentName = ProxiedComponent.displayName;

		deprecated( `wp.components.__unstable${ componentName }`, {
			alternative: `wp.components.${ componentName }`,
		} );

		const { store, ...rest } =
			mapLegacyStatePropsToComponentProps( legacyProps );
		const props = rest as Record< keyof ComponentProps< C >, any >;

		Object.entries( propMap ).forEach( ( [ from, to ] ) => {
			if ( props.hasOwnProperty( from ) ) {
				// TypeScript doesn't like it if we directly set `to`
				// on props, i.e. `props[ to ] = props[ from ]`.
				Object.assign( props, { [ to ]: props[ from ] } );
				delete props[ from ];
			}
		} );

		const { baseId, id } = props;
		Object.assign( props, { id: useInstanceId( store, baseId, id ) } );
		delete props.baseId;

		return <ProxiedComponent { ...props } store={ store } />;
	};
}

export const Composite = proxyComposite( Current.Composite, { baseId: 'id' } );

export const CompositeGroup = proxyComposite<
	typeof Current.CompositeGroup | typeof Current.CompositeRow
>(
	forwardRef<
		any,
		| ComponentProps< typeof Current.CompositeRow >
		| ComponentProps< typeof Current.CompositeGroup >
	>( function CompositeGroup( { role, ...props }, ref ) {
		const Component =
			role === 'row' ? Current.CompositeRow : Current.CompositeGroup;
		return <Component ref={ ref } role={ role } { ...props } />;
	} )
);

export const CompositeItem = proxyComposite( Current.CompositeItem, {
	focusable: 'accessibleWhenDisabled',
} );

export function useCompositeState(
	initialState: InitialStateProps = {}
): CompositeState {
	deprecated( 'wp.components.__unstableUseCompositeState', {
		alternative: 'wp.components.useCompositeStore',
	} );

	const {
		baseId,
		currentId: defaultActiveId,
		orientation,
		rtl = false,
		loop: focusLoop = false,
		wrap: focusWrap = false,
		shift: focusShift = false,
		// eslint-disable-next-line camelcase
		unstable_virtual: virtualFocus,
	} = initialState;

	return {
		baseId: useBaseId( baseId ),
		store: Current.useCompositeStore( {
			defaultActiveId,
			rtl,
			orientation,
			focusLoop,
			focusShift,
			focusWrap,
			virtualFocus,
		} ),
	};
}
